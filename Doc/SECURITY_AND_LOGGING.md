# Механизмы защиты и логирования

В проекте используются как встроенные средства используемых библиотек, так и собственная программная логика безопасности и логирования. Ниже они описаны без фрагментов кода.

---

## 1. Аутентификация и авторизация

**JWT (JSON Web Token)**  
Вход в систему выполняется по email и паролю. Сервер проверяет учётные данные и выдаёт JWT. Токен передаётся в заголовке запроса и проверяется на защищённых маршрутах. Срок действия токена задаётся в конфигурации (например, 7 дней). В production требуется задать достаточно длинный и случайный секретный ключ подписи (не менее 32 символов); при некорректном или отсутствующем секрете в production приложение может не запускаться.

**Проверка доступа (middleware)**  
Для защищённых API используется middleware аутентификации: проверяется наличие и валидность JWT. При отсутствии или невалидности токена возвращается ответ с кодом 401. Отдельный middleware авторизации проверяет роль пользователя: доступ к определённым маршрутам разрешён только указанным ролям (например, только администратору или администратору и модератору). При недостаточных правах возвращается 403.

**Опциональная аутентификация**  
Часть маршрутов может работать и без токена (гостевой доступ). Для них используется опциональная аутентификация: если токен передан и валиден, данные пользователя добавляются в запрос; если нет — запрос обрабатывается как от гостя, без блокировки.

**Хранение паролей**  
Пароли не хранятся в открытом виде. Используется хеширование с помощью bcrypt (с раундами соли). При входе сравнивается только хеш; восстановление исходного пароля по базе невозможно.

---

## 2. Валидация паролей

При регистрации и смене пароля применяются настраиваемые правила:

- минимальная и максимальная длина пароля;
- обязательность заглавных букв, строчных букв, цифр;
- при необходимости — обязательность спецсимволов.

Проверки включаются и настраиваются через переменные окружения. Несоответствие правилам возвращает ошибку валидации без создания учётной записи или смены пароля.

---

## 3. Ограничение частоты запросов (Rate Limiting)

Используется трёхуровневое ограничение частоты запросов (все параметры задаются в .env):

**Общий лимит**  
Ограничивает число запросов с одного IP за заданный интервал времени ко всем API. Снижает риск перегрузки сервера и простых DDoS-сценариев. При превышении лимита возвращается код 429 и сообщение о превышении лимита; факт превышения записывается в логи.

**Лимит на аутентификацию**  
Отдельный лимит на попытки входа и регистрации (например, не более 10 попыток за 15 минут с одного IP). Защита от подбора паролей. Успешные попытки входа при необходимости не учитываются в счётчике. При превышении — 429 и запись в логи.

**Лимит на загрузку файлов**  
Ограничение числа загрузок с одного IP за период (например, за час). Защита от злоупотребления диском и спама файлами. При превышении — 429 и запись в логи.

Каждый из лимитов можно включить или отключить независимо через переменные окружения. В ответах при необходимости добавляются стандартные заголовки с информацией о лимите.

---

## 4. HTTP-заголовки безопасности (Helmet)

Подключён middleware Helmet. Он выставляет безопасные HTTP-заголовки, в том числе:

- ограничение источника загрузки контента (в т.ч. изображений);
- ограничение источников стилей и скриптов;
- ограничение источников для запросов (в т.ч. WebSocket);
- политика перекрёстных ресурсов для встроенного контента.

Политики настроены так, чтобы разрешить работу фронтенда (в т.ч. изображения с того же источника, data:, blob:, локальный разработческий сервер) и блокировать типичные векторы атак через заголовки. Включение и отключение Helmet задаётся переменной окружения.

---

## 5. CORS (Cross-Origin Resource Sharing)

CORS включён и настраивается через переменные окружения: разрешённый origin (адрес фронтенда), разрешение передачи учётных данных (cookies, заголовки авторизации). Запросы с других источников браузер блокирует по правилам CORS. В production необходимо указать реальный origin фронтенда, а не подстановочный символ.

---

## 6. Санитизация и валидация контента

**Санитизация HTML**  
Если включена соответствующая настройка, ввод пользователя, который может содержать HTML (например, в новостях или описаниях), обрабатывается библиотекой санитизации (DOMPurify на backend). Это снижает риск XSS при отображении контента.

**Санитизация логов**  
Перед записью в файлы и консоль все сообщения и метаданные логов проходят через модуль санитизации. В логах маскируются:

- поля с именами, указывающими на чувствительные данные (пароль, токен, email, телефон, сессия и т.п.);
- вхождения email и телефонов в произвольном тексте.

Вместо реальных значений подставляются метки вроде [REDACTED] или [EMAIL_REDACTED], [PHONE_REDACTED]. Таким образом, даже при логировании тела запроса или ответа персональные данные в файлах логов не сохраняются. Включение санитизации задаётся переменной окружения.

---

## 7. Валидация загружаемых файлов

**Проверка типа файла**  
Для загрузок используется проверка по MIME-типу и по сигнатуре файла (magic bytes). Это не позволяет обойти ограничения путём подмены расширения (например, загрузить исполняемый файл под видом изображения). Разрешённые типы заданы для изображений (JPEG, PNG, GIF, WebP) и документов (PDF, Word, Excel, текст, CSV и т.д.). Проверка magic bytes и MIME включается/выключается в конфигурации.

**Ограничение размера**  
Максимальный размер загружаемого файла задаётся в конфигурации (отдельно для обычных загрузок и для документов). Превышение размера приводит к отклонению загрузки.

**Защита от path traversal**  
При сохранении файла итоговый путь вычисляется только внутри разрешённой директории загрузок. Попытки подставить путь вроде «../» приводят к ошибке и отказу в сохранении. Имена файлов очищаются от опасных символов и при необходимости дополняются уникальным суффиксом, чтобы избежать перезаписи и коллизий.

---

## 8. Логирование на уровне приложения (Winston)

Используется централизованный логгер на базе Winston. Все сообщения перед записью проходят через санитизацию (см. выше). Уровень логирования зависит от режима (development/production). Логи пишутся в файлы в директории логов с ротацией по дате и размеру: отдельный файл для ошибок (уровень error), общий файл для всех уровней, а также файлы для необработанных исключений и отклонённых промисов. Старые файлы при необходимости сжимаются и удаляются по настройкам (например, хранение за последние 30 дней). В режиме разработки дублирование в консоль с цветным форматированием. Таким образом обеспечивается аудит ошибок и работа приложения без переполнения диска логами.

---

## 9. Системные логи действий (таблица SystemLog)

В базе данных ведётся таблица системных логов. В ней фиксируются действия пользователей над сущностями: создание, обновление, удаление. Для каждой записи сохраняются:

- идентификатор и данные пользователя (кто выполнил действие);
- тип действия (CREATE, UPDATE, DELETE);
- тип сущности и её идентификатор;
- название или описание сущности (если применимо);
- старые и новые значения (для обновлений и удалений);
- описание действия;
- IP и User-Agent запроса;
- время операции.

Запись в системный лог выполняется через middleware, подключённый к ORM: при любом создании, обновлении или удалении через ORM формируется запись лога с контекстом пользователя из текущего запроса. Операции чтения и запись в саму таблицу логов не логируются, чтобы избежать рекурсии. Администратор может просматривать и фильтровать эти логи в разделе «Логирование» панели администратора.

---

## 10. Настройки хранения системных логов и автоочистка

Срок хранения записей в таблице системных логов настраивается (например, неделя, месяц, три месяца, полгода, год). Планировщик задач раз в сутки (по расписанию, например в 3:00 по московскому времени) запускает очистку: удаляются записи старше выбранного срока. Это ограничивает рост таблицы логов и соответствует политике хранения данных. Настройки хранятся в файле в рабочей директории backend; при отсутствии файла используется значение по умолчанию (например, месяц).

---

## 11. Логи с фронтенда

Реализован приём логов с клиента (ошибки, предупреждения) и сохранение их на сервере. Это позволяет анализировать сбои в браузере пользователя без доступа к его консоли. Отправка и хранение могут быть ограничены правами доступа и конфигурацией.

---

## 12. Резюме

Используются: аутентификация по JWT и проверка ролей; хранение паролей в виде хешей; валидация паролей при регистрации; ограничение частоты запросов (общее, для входа, для загрузок); безопасные заголовки (Helmet); CORS; санитизация HTML и логов; валидация и безопасное сохранение файлов; файловое логирование с ротацией и санитизацией; логирование действий в БД с настраиваемой автоочисткой. Включение и параметры большинства механизмов задаются переменными окружения и не требуют правок кода.
